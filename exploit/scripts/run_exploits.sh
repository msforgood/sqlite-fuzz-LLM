#!/bin/bash -eu
# SQLite3 Exploit Execution Script
# Safely executes exploit programs with logging and monitoring

set -o pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
EXPLOIT_DIR="$ROOT_DIR/exploit"
BIN_DIR="$EXPLOIT_DIR/bin"
RESULTS_DIR="$EXPLOIT_DIR/results"

# Available exploits
EXPLOITS=(
    "btree_overflow_exploit"
    "vdbe_uaf_exploit"
    "format_string_exploit"
    "wal_race_exploit"
)

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

show_help() {
    echo "=== SQLite3 Exploit Execution System ==="
    echo "WARNING: For defensive security research only!"
    echo ""
    echo "Usage: $0 <exploit_name> [options]"
    echo ""
    echo "Available exploits:"
    for exploit in "${EXPLOITS[@]}"; do
        echo "  - $exploit"
    done
    echo "  - all (run all exploits)"
    echo ""
    echo "Options:"
    echo "  --debug     Use debug version with AddressSanitizer"
    echo "  --coverage  Use coverage version for analysis"
    echo "  --timeout   Set timeout in seconds (default: 60)"
    echo "  --log       Log output to file"
    echo "  --monitor   Monitor system resources during execution"
    echo ""
    echo "Examples:"
    echo "  $0 btree_overflow_exploit --debug"
    echo "  $0 all --timeout 120 --log"
    echo "  $0 vdbe_uaf_exploit --coverage --monitor"
}

setup_environment() {
    echo -e "${BLUE}[+] Setting up exploit environment${NC}"
    
    # Create results directory
    mkdir -p "$RESULTS_DIR"
    
    # Clear old core dumps
    rm -f core core.* 2>/dev/null || true
    
    # Set core dump pattern
    echo "core.%e.%p.%t" > /proc/sys/kernel/core_pattern 2>/dev/null || true
    
    # Enable core dumps
    ulimit -c unlimited 2>/dev/null || true
    
    # Set memory limits to prevent system crash
    ulimit -v 4194304  # 4GB virtual memory limit
    ulimit -m 2097152  # 2GB resident memory limit
    
    echo -e "${GREEN}[+] Environment setup completed${NC}"
}

monitor_resources() {
    local exploit_name="$1"
    local pid="$2"
    local log_file="$3"
    
    echo "[MONITOR] Starting resource monitoring for PID $pid" >> "$log_file"
    
    while kill -0 "$pid" 2>/dev/null; do
        # Log memory usage
        ps -p "$pid" -o pid,ppid,rss,vsz,pcpu,pmem,cmd 2>/dev/null >> "$log_file" || break
        
        # Log system memory
        free -m >> "$log_file" 2>/dev/null
        
        # Check for core dumps
        if ls core.* >/dev/null 2>&1; then
            echo "[MONITOR] Core dump detected!" >> "$log_file"
            break
        fi
        
        sleep 1
    done
    
    echo "[MONITOR] Resource monitoring completed for $exploit_name" >> "$log_file"
}

run_single_exploit() {
    local exploit_name="$1"
    local version="$2"  # "release", "debug", or "coverage"
    local timeout="$3"
    local use_log="$4"
    local use_monitor="$5"
    
    local binary_name="$exploit_name"
    if [[ "$version" != "release" ]]; then
        binary_name="${exploit_name}_${version}"
    fi
    
    local binary_path="$BIN_DIR/$binary_name"
    
    if [[ ! -x "$binary_path" ]]; then
        echo -e "${RED}[-] Exploit binary not found: $binary_path${NC}"
        echo "Run './scripts/build_exploits.sh' first"
        return 1
    fi
    
    local timestamp=$(date '+%Y%m%d_%H%M%S')
    local log_file="$RESULTS_DIR/${exploit_name}_${version}_${timestamp}.log"
    local result_file="$RESULTS_DIR/${exploit_name}_${version}_${timestamp}.result"
    
    echo -e "${BLUE}=== Running $exploit_name ($version version) ===${NC}"
    echo "Binary: $binary_path"
    echo "Timeout: ${timeout}s"
    echo "Log file: $log_file"
    echo "Result file: $result_file"
    echo ""
    
    # Prepare log file
    if [[ "$use_log" = "true" ]]; then
        echo "=== SQLite3 Exploit Execution Log ===" > "$log_file"
        echo "Exploit: $exploit_name" >> "$log_file"
        echo "Version: $version" >> "$log_file"
        echo "Timestamp: $(date)" >> "$log_file"
        echo "Binary: $binary_path" >> "$log_file"
        echo "Timeout: ${timeout}s" >> "$log_file"
        echo "=========================================" >> "$log_file"
        echo "" >> "$log_file"
    fi
    
    # Change to exploit directory
    cd "$EXPLOIT_DIR"
    
    # Execute exploit with timeout and monitoring
    local exit_code=0
    local start_time=$(date +%s)
    
    if [[ "$use_log" = "true" && "$use_monitor" = "true" ]]; then
        # Run with full monitoring and logging
        timeout "$timeout" "$binary_path" > >(tee -a "$log_file") 2>&1 &
        local exploit_pid=$!
        
        # Start resource monitoring
        monitor_resources "$exploit_name" "$exploit_pid" "$log_file" &
        local monitor_pid=$!
        
        # Wait for exploit to complete
        wait "$exploit_pid" 2>/dev/null
        exit_code=$?
        
        # Stop monitoring
        kill "$monitor_pid" 2>/dev/null || true
        wait "$monitor_pid" 2>/dev/null || true
        
    elif [[ "$use_log" = "true" ]]; then
        # Run with logging only
        timeout "$timeout" "$binary_path" >> "$log_file" 2>&1
        exit_code=$?
        
    else
        # Run without logging
        timeout "$timeout" "$binary_path"
        exit_code=$?
    fi
    
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    
    # Analyze results
    echo ""
    echo -e "${BLUE}=== Execution Results ===${NC}"
    echo "Duration: ${duration}s"
    echo "Exit code: $exit_code"
    
    # Create result summary
    {
        echo "=== SQLite3 Exploit Execution Result ==="
        echo "Exploit: $exploit_name"
        echo "Version: $version"
        echo "Exit code: $exit_code"
        echo "Duration: ${duration}s"
        echo "Timestamp: $(date)"
        echo ""
    } > "$result_file"
    
    # Check for crashes and vulnerabilities
    local vulnerability_detected=false
    
    if [[ $exit_code -eq 124 ]]; then
        echo -e "${YELLOW}[!] Exploit timed out after ${timeout}s${NC}"
        echo "Status: TIMEOUT" >> "$result_file"
    elif [[ $exit_code -eq 139 ]]; then
        echo -e "${RED}[!] SEGMENTATION FAULT DETECTED${NC}"
        echo "Status: SEGFAULT (potential vulnerability)" >> "$result_file"
        vulnerability_detected=true
    elif [[ $exit_code -eq 134 ]]; then
        echo -e "${RED}[!] ABORT SIGNAL DETECTED${NC}"
        echo "Status: ABORT (potential vulnerability)" >> "$result_file"
        vulnerability_detected=true
    elif [[ $exit_code -eq 1 ]]; then
        echo -e "${YELLOW}[!] Exploit detected potential vulnerability${NC}"
        echo "Status: VULNERABILITY_DETECTED" >> "$result_file"
        vulnerability_detected=true
    elif [[ $exit_code -eq 0 ]]; then
        echo -e "${GREEN}[+] Exploit completed without crash${NC}"
        echo "Status: COMPLETED_SAFELY" >> "$result_file"
    else
        echo -e "${YELLOW}[!] Unexpected exit code: $exit_code${NC}"
        echo "Status: UNEXPECTED_EXIT" >> "$result_file"
    fi
    
    # Check for core dumps
    if ls core.* >/dev/null 2>&1; then
        echo -e "${RED}[!] CORE DUMP DETECTED${NC}"
        echo "Core dumps: $(ls core.*)" >> "$result_file"
        vulnerability_detected=true
        
        # Move core dumps to results directory
        mv core.* "$RESULTS_DIR/" 2>/dev/null || true
    fi
    
    # Check AddressSanitizer output (if debug version)
    if [[ "$version" = "debug" && "$use_log" = "true" ]]; then
        if grep -q "AddressSanitizer" "$log_file" 2>/dev/null; then
            echo -e "${RED}[!] ADDRESSSANITIZER DETECTED ISSUES${NC}"
            echo "AddressSanitizer: ISSUES_DETECTED" >> "$result_file"
            vulnerability_detected=true
        fi
    fi
    
    # Final status
    if [[ "$vulnerability_detected" = "true" ]]; then
        echo -e "${RED}[!] POTENTIAL VULNERABILITY DETECTED${NC}"
        echo "Check $result_file and $log_file for details"
        echo ""
        echo -e "${RED}⚠️  SECURITY ALERT ⚠️${NC}"
        echo "This exploit may have successfully triggered a vulnerability."
        echo "Review the results carefully for security implications."
    else
        echo -e "${GREEN}[+] No obvious vulnerabilities detected${NC}"
        echo "This could mean the exploit failed, or protections are active."
    fi
    
    echo ""
    return $exit_code
}

main() {
    if [[ $# -eq 0 ]]; then
        show_help
        exit 1
    fi
    
    local exploit_name="$1"
    shift
    
    local version="release"
    local timeout=60
    local use_log=false
    local use_monitor=false
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case $1 in
            --debug)
                version="debug"
                shift
                ;;
            --coverage)
                version="coverage"
                shift
                ;;
            --timeout)
                timeout="$2"
                shift 2
                ;;
            --log)
                use_log=true
                shift
                ;;
            --monitor)
                use_monitor=true
                use_log=true  # Monitoring requires logging
                shift
                ;;
            --help)
                show_help
                exit 0
                ;;
            *)
                echo "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done
    
    echo -e "${RED}⚠️  SECURITY WARNING ⚠️${NC}"
    echo "These exploits are for defensive security research only!"
    echo "Do not use for malicious purposes."
    echo "Ensure you are in a controlled environment."
    echo ""
    read -p "Continue? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Aborted."
        exit 1
    fi
    
    setup_environment
    
    if [[ "$exploit_name" = "all" ]]; then
        echo -e "${BLUE}[+] Running all exploits${NC}"
        echo ""
        
        local total_vulnerabilities=0
        for exploit in "${EXPLOITS[@]}"; do
            if run_single_exploit "$exploit" "$version" "$timeout" "$use_log" "$use_monitor"; then
                :  # Success
            else
                local exit_code=$?
                if [[ $exit_code -eq 1 || $exit_code -eq 139 || $exit_code -eq 134 ]]; then
                    ((total_vulnerabilities++))
                fi
            fi
            echo ""
        done
        
        echo -e "${BLUE}=== Final Summary ===${NC}"
        echo "Total exploits run: ${#EXPLOITS[@]}"
        echo "Potential vulnerabilities detected: $total_vulnerabilities"
        
        if [[ $total_vulnerabilities -gt 0 ]]; then
            echo -e "${RED}[!] $total_vulnerabilities potential vulnerabilities found${NC}"
        else
            echo -e "${GREEN}[+] No obvious vulnerabilities detected${NC}"
        fi
        
    else
        # Check if exploit exists
        local exploit_found=false
        for exploit in "${EXPLOITS[@]}"; do
            if [[ "$exploit" = "$exploit_name" ]]; then
                exploit_found=true
                break
            fi
        done
        
        if [[ "$exploit_found" = "false" ]]; then
            echo -e "${RED}[-] Unknown exploit: $exploit_name${NC}"
            echo "Available exploits: ${EXPLOITS[*]}"
            exit 1
        fi
        
        run_single_exploit "$exploit_name" "$version" "$timeout" "$use_log" "$use_monitor"
    fi
}

main "$@"