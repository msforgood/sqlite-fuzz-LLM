/*
** SQLite3 Vulnerability Detection Harness Implementation
** 식별된 취약점들을 특별히 타겟팅하는 향상된 퍼징 하니스
*/

#include "vulnerability_detection_harness.h"
#include "sqlite3.h"
#include <signal.h>
#include <setjmp.h>
#include <sys/mman.h>
#include <unistd.h>
#include <fcntl.h>

/* Global variables for vulnerability detection */
static volatile sig_atomic_t infinite_loop_detected = 0;
static volatile sig_atomic_t segfault_detected = 0;
static jmp_buf vulnerability_recovery_point;
static int vulnerability_detection_active = 0;

/* Signal handlers for vulnerability detection */
static void sigalrm_handler(int sig) {
    infinite_loop_detected = 1;
    if (vulnerability_detection_active) {
        longjmp(vulnerability_recovery_point, 1);
    }
}

static void sigsegv_handler(int sig) {
    segfault_detected = 1;
    if (vulnerability_detection_active) {
        longjmp(vulnerability_recovery_point, 2);
    }
}

/*
** Enhanced B-Tree allocateBtreePage Vulnerability Detection
** Targets integer overflow in btree.c:6475-6700
*/
int fuzz_btree_allocate_page_vulnerability(FuzzCtx *ctx, const uint8_t *data, size_t size) {
    if (size < sizeof(btree_overflow_packet)) return 0;
    
    const btree_overflow_packet *packet = (const btree_overflow_packet *)data;
    
    /* Validation with focus on triggering integer overflow */
    if (packet->freelist_count > VULN_MAX_PAGE_COUNT) return 0;
    
    sqlite3 *db = NULL;
    int rc = sqlite3_open(":memory:", &db);
    if (rc != SQLITE_OK) return 0;
    
    /* Set up signal handlers for vulnerability detection */
    signal(SIGALRM, sigalrm_handler);
    signal(SIGSEGV, sigsegv_handler);
    vulnerability_detection_active = 1;
    
    if (setjmp(vulnerability_recovery_point) != 0) {
        /* Vulnerability detected - cleanup and report */
        vulnerability_detection_active = 0;
        if (infinite_loop_detected) {
            /* Integer overflow causing infinite loop detected */
            alarm(0);
        }
        sqlite3_close(db);
        return 0;
    }
    
    /* Set alarm to detect infinite loops */
    alarm(2); /* 2 second timeout */
    
    /* Test different integer overflow scenarios */
    switch (packet->scenario & 0x7) {
        case 0: {
            /* Scenario 1: Large freelist count (0xFFFFFFFE) */
            sqlite3_exec(db, "CREATE TABLE t1(x INTEGER)", NULL, NULL, NULL);
            
            /* Try to trigger allocateBtreePage with large freelist count */
            for (int i = 0; i < 1000 && !infinite_loop_detected; i++) {
                char *sql = sqlite3_mprintf("INSERT INTO t1 VALUES(%d)", 
                                           (int)(packet->boundary_values[i % 4]));
                if (sql) {
                    sqlite3_exec(db, sql, NULL, NULL, NULL);
                    sqlite3_free(sql);
                }
                
                /* Force page allocation */
                sqlite3_exec(db, "VACUUM", NULL, NULL, NULL);
            }
            break;
        }
        case 1: {
            /* Scenario 2: Boundary value testing for nSearch overflow */
            sqlite3_exec(db, "CREATE TABLE t1(data BLOB)", NULL, NULL, NULL);
            
            /* Generate large amount of data to trigger page allocation */
            for (int i = 0; i < 100 && !infinite_loop_detected; i++) {
                sqlite3_stmt *stmt;
                if (sqlite3_prepare_v2(db, "INSERT INTO t1 VALUES(?)", -1, &stmt, NULL) == SQLITE_OK) {
                    /* Create data that will cause multiple page allocations */
                    size_t blob_size = (packet->leaf_count % 65536) + 1024;
                    sqlite3_bind_blob(stmt, 1, packet->test_data, blob_size, SQLITE_STATIC);
                    sqlite3_step(stmt);
                    sqlite3_finalize(stmt);
                }
            }
            break;
        }
        case 2: {
            /* Scenario 3: Trunk page manipulation */
            sqlite3_exec(db, "PRAGMA page_size=512", NULL, NULL, NULL);
            sqlite3_exec(db, "CREATE TABLE t1(x)", NULL, NULL, NULL);
            
            /* Create pattern that might trigger trunk page issues */
            for (int i = 0; i < 50; i++) {
                char *sql = sqlite3_mprintf("INSERT INTO t1 VALUES(randomblob(%d))", 
                                           (int)(packet->leaf_count % 1000 + 100));
                if (sql) {
                    sqlite3_exec(db, sql, NULL, NULL, NULL);
                    sqlite3_free(sql);
                    
                    /* Periodically delete to create free pages */
                    if (i % 10 == 0) {
                        sqlite3_exec(db, "DELETE FROM t1 WHERE rowid % 3 = 0", NULL, NULL, NULL);
                    }
                }
            }
            break;
        }
        case 3: {
            /* Scenario 4: Maximum page count boundary testing */
            sqlite3_exec(db, "PRAGMA max_page_count=1000", NULL, NULL, NULL);
            sqlite3_exec(db, "CREATE TABLE t1(large_data TEXT)", NULL, NULL, NULL);
            
            /* Try to exceed page limits */
            for (int i = 0; i < 200; i++) {
                char *sql = sqlite3_mprintf("INSERT INTO t1 VALUES('%.*s')", 
                                           (int)(packet->search_limit % 1000), packet->test_data);
                if (sql) {
                    sqlite3_exec(db, sql, NULL, NULL, NULL);
                    sqlite3_free(sql);
                }
            }
            break;
        }
        default: {
            /* Scenario 5: Mixed allocation patterns */
            sqlite3_exec(db, "CREATE TABLE t1(a, b, c)", NULL, NULL, NULL);
            sqlite3_exec(db, "CREATE INDEX idx1 ON t1(a)", NULL, NULL, NULL);
            
            /* Mixed operations to stress page allocator */
            for (int i = 0; i < 100; i++) {
                char *sql = sqlite3_mprintf("INSERT INTO t1 VALUES(%d, '%.*s', %d)", 
                                           i, 16, packet->test_data, i * 2);
                if (sql) {
                    sqlite3_exec(db, sql, NULL, NULL, NULL);
                    sqlite3_free(sql);
                }
                
                if (i % 20 == 0) {
                    sqlite3_exec(db, "DELETE FROM t1 WHERE a % 5 = 0", NULL, NULL, NULL);
                    sqlite3_exec(db, "VACUUM", NULL, NULL, NULL);
                }
            }
            break;
        }
    }
    
    /* Disable alarm and signal handlers */
    alarm(0);
    vulnerability_detection_active = 0;
    signal(SIGALRM, SIG_DFL);
    signal(SIGSEGV, SIG_DFL);
    
    sqlite3_close(db);
    return 0;
}

/*
** VDBE Memory Use-After-Free Vulnerability Detection
** Targets sqlite3VdbeMemMakeWriteable UAF in vdbemem.c:283
*/
int fuzz_vdbe_memory_uaf_vulnerability(FuzzCtx *ctx, const uint8_t *data, size_t size) {
    if (size < sizeof(vdbe_uaf_packet)) return 0;
    
    const vdbe_uaf_packet *packet = (const vdbe_uaf_packet *)data;
    
    /* Validation to trigger UAF scenarios */
    if (packet->initial_size > 10000000) return 0;
    if (packet->target_size > 10000000) return 0;
    
    sqlite3 *db = NULL;
    int rc = sqlite3_open(":memory:", &db);
    if (rc != SQLITE_OK) return 0;
    
    /* Set up memory pressure if requested */
    if (packet->pressure_level > 0) {
        simulate_memory_pressure(packet->pressure_level % 100, 
                                packet->initial_size % 65536);
    }
    
    /* Test different UAF scenarios */
    switch (packet->scenario & 0x7) {
        case 0: {
            /* Scenario 1: Large blob reallocation UAF */
            sqlite3_exec(db, "CREATE TABLE t1(data BLOB)", NULL, NULL, NULL);
            
            /* Create large blob that will trigger MakeWriteable */
            sqlite3_stmt *stmt;
            if (sqlite3_prepare_v2(db, "INSERT INTO t1 VALUES(?)", -1, &stmt, NULL) == SQLITE_OK) {
                sqlite3_bind_blob(stmt, 1, packet->payload_data, 
                                 packet->initial_size % 1000, SQLITE_TRANSIENT);
                sqlite3_step(stmt);
                sqlite3_finalize(stmt);
            }
            
            /* Operations that trigger MakeWriteable and potential UAF */
            sqlite3_exec(db, "SELECT length(data), substr(data, 1, 500000) FROM t1", NULL, NULL, NULL);
            sqlite3_exec(db, "SELECT data || randomblob(500000) FROM t1", NULL, NULL, NULL);
            break;
        }
        case 1: {
            /* Scenario 2: String concatenation UAF */
            sqlite3_exec(db, "CREATE TABLE t1(str TEXT)", NULL, NULL, NULL);
            
            char *large_str = sqlite3_mprintf("%.*s", 
                                             (int)(packet->target_size % 10000), packet->payload_data);
            char *sql = sqlite3_mprintf("INSERT INTO t1 VALUES('%s')", large_str);
            if (sql) {
                sqlite3_exec(db, sql, NULL, NULL, NULL);
                sqlite3_free(sql);
            }
            sqlite3_free(large_str);
            
            /* Trigger reallocation scenarios */
            sqlite3_exec(db, "SELECT str || str || str FROM t1", NULL, NULL, NULL);
            sqlite3_exec(db, "SELECT upper(str), lower(str) FROM t1", NULL, NULL, NULL);
            break;
        }
        case 2: {
            /* Scenario 3: Multiple memory type conversions */
            sqlite3_exec(db, "CREATE TABLE t1(val)", NULL, NULL, NULL);
            
            for (int i = 0; i < 20; i++) {
                char *sql = sqlite3_mprintf("INSERT INTO t1 VALUES('%.*s')", 
                                           (int)(packet->fragment_count % 100), packet->payload_data);
                if (sql) {
                    sqlite3_exec(db, sql, NULL, NULL, NULL);
                    sqlite3_free(sql);
                }
            }
            
            /* Operations that cause memory type changes and potential UAF */
            sqlite3_exec(db, "SELECT CAST(val AS INTEGER), CAST(val AS REAL), CAST(val AS BLOB) FROM t1", NULL, NULL, NULL);
            break;
        }
        case 3: {
            /* Scenario 4: Ephemeral memory UAF */
            sqlite3_exec(db, "CREATE TABLE t1(x)", NULL, NULL, NULL);
            
            /* Create scenario with ephemeral memory */
            for (int i = 0; i < 10; i++) {
                sqlite3_stmt *stmt;
                char *sql = "SELECT randomblob(?) || ? || randomblob(?)";
                if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) == SQLITE_OK) {
                    sqlite3_bind_int(stmt, 1, packet->initial_size % 1000);
                    sqlite3_bind_blob(stmt, 2, packet->payload_data, 32, SQLITE_STATIC);
                    sqlite3_bind_int(stmt, 3, packet->target_size % 1000);
                    
                    while (sqlite3_step(stmt) == SQLITE_ROW) {
                        /* Access data to trigger memory operations */
                        const void *blob = sqlite3_column_blob(stmt, 0);
                        int blob_len = sqlite3_column_bytes(stmt, 0);
                        (void)blob; (void)blob_len; /* Use variables to avoid warnings */
                    }
                    sqlite3_finalize(stmt);
                }
            }
            break;
        }
        default: {
            /* Scenario 5: Complex memory operations */
            sqlite3_exec(db, "CREATE TABLE t1(a TEXT, b BLOB, c REAL)", NULL, NULL, NULL);
            
            /* Insert mixed data types */
            for (int i = 0; i < 15; i++) {
                char *sql = sqlite3_mprintf("INSERT INTO t1 VALUES('%.*s', ?, %f)", 
                                           16, packet->payload_data, (double)i / 100.0);
                if (sql) {
                    sqlite3_stmt *stmt;
                    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) == SQLITE_OK) {
                        sqlite3_bind_blob(stmt, 1, packet->payload_data, 
                                         packet->alloc_pattern % 64, SQLITE_TRANSIENT);
                        sqlite3_step(stmt);
                        sqlite3_finalize(stmt);
                    }
                    sqlite3_free(sql);
                }
            }
            
            /* Complex operations that stress memory management */
            sqlite3_exec(db, "SELECT a || b, length(a), typeof(c), hex(b) FROM t1", NULL, NULL, NULL);
            break;
        }
    }
    
    sqlite3_close(db);
    return 0;
}

/*
** Format String Attack Vulnerability Detection
** Targets sqlite3_mprintf format string vulnerabilities
*/
int fuzz_format_string_attack(FuzzCtx *ctx, const uint8_t *data, size_t size) {
    if (size < sizeof(format_string_packet)) return 0;
    
    const format_string_packet *packet = (const format_string_packet *)data;
    
    /* Validation */
    if (packet->string_length > 1000) return 0;
    
    sqlite3 *db = NULL;
    int rc = sqlite3_open(":memory:", &db);
    if (rc != SQLITE_OK) return 0;
    
    /* Test different format string attack scenarios */
    switch (packet->scenario & 0x7) {
        case 0: {
            /* Scenario 1: Virtual table name format string */
            char safe_table_name[128];
            snprintf(safe_table_name, sizeof(safe_table_name), "table_%.*s", 
                    (int)(packet->string_length % 50), packet->table_name);
            
            /* Try to create virtual table with potentially malicious name */
            char *sql = sqlite3_mprintf("CREATE TABLE \"%s\" (id INTEGER)", safe_table_name);
            if (sql) {
                sqlite3_exec(db, sql, NULL, NULL, NULL);
                sqlite3_free(sql);
            }
            break;
        }
        case 1: {
            /* Scenario 2: PRAGMA value format string */
            char pragma_value[256];
            snprintf(pragma_value, sizeof(pragma_value), "%.*s", 
                    (int)(packet->string_length % 200), packet->format_payload);
            
            /* Test various PRAGMA statements */
            char *sql = sqlite3_mprintf("PRAGMA user_version = '%s'", pragma_value);
            if (sql) {
                sqlite3_exec(db, sql, NULL, NULL, NULL);
                sqlite3_free(sql);
            }
            break;
        }
        case 2: {
            /* Scenario 3: Error message format string */
            sqlite3_exec(db, "CREATE TABLE t1(x)", NULL, NULL, NULL);
            
            /* Try to trigger error messages with format strings */
            char malicious_column[128];
            snprintf(malicious_column, sizeof(malicious_column), "%.*s", 
                    (int)(packet->string_length % 100), packet->format_payload);
            
            char *sql = sqlite3_mprintf("SELECT \"%s\" FROM t1", malicious_column);
            if (sql) {
                sqlite3_exec(db, sql, NULL, NULL, NULL);
                sqlite3_free(sql);
            }
            break;
        }
        case 3: {
            /* Scenario 4: Function name format string */
            sqlite3_exec(db, "CREATE TABLE t1(data TEXT)", NULL, NULL, NULL);
            sqlite3_exec(db, "INSERT INTO t1 VALUES('test')", NULL, NULL, NULL);
            
            /* Test with potentially malicious function usage */
            char func_call[256];
            snprintf(func_call, sizeof(func_call), "SELECT '%.*s' FROM t1", 
                    (int)(packet->string_length % 200), packet->format_payload);
            
            sqlite3_exec(db, func_call, NULL, NULL, NULL);
            break;
        }
        default: {
            /* Scenario 5: Complex format string combinations */
            char combined_attack[512];
            snprintf(combined_attack, sizeof(combined_attack), 
                    "CREATE TEMP TABLE \"%.*s\" AS SELECT '%.*s' AS col",
                    (int)(packet->string_length % 100), packet->table_name,
                    (int)(packet->string_length % 300), packet->format_payload);
            
            sqlite3_exec(db, combined_attack, NULL, NULL, NULL);
            break;
        }
    }
    
    sqlite3_close(db);
    return 0;
}

/*
** WAL Race Condition Vulnerability Detection
** Targets sqlite3BtreeCheckpoint TOCTOU in btree.c:11296
*/
int fuzz_wal_race_condition(FuzzCtx *ctx, const uint8_t *data, size_t size) {
    if (size < sizeof(wal_race_packet)) return 0;
    
    const wal_race_packet *packet = (const wal_race_packet *)data;
    
    /* Validation */
    if (packet->thread_count > 10) return 0;
    if (packet->operation_count > 100) return 0;
    
    /* Create temporary database file for WAL testing */
    char temp_db_path[] = "/tmp/sqlite_race_test_XXXXXX";
    int fd = mkstemp(temp_db_path);
    if (fd == -1) return 0;
    close(fd);
    
    sqlite3 *db = NULL;
    int rc = sqlite3_open(temp_db_path, &db);
    if (rc != SQLITE_OK) {
        unlink(temp_db_path);
        return 0;
    }
    
    /* Enable WAL mode */
    sqlite3_exec(db, "PRAGMA journal_mode=WAL", NULL, NULL, NULL);
    sqlite3_exec(db, "CREATE TABLE t1(id INTEGER, data TEXT)", NULL, NULL, NULL);
    
    /* Test different race condition scenarios */
    switch (packet->scenario & 0x3) {
        case 0: {
            /* Scenario 1: Checkpoint vs Transaction race */
            /* Insert some initial data */
            for (int i = 0; i < 10; i++) {
                char *sql = sqlite3_mprintf("INSERT INTO t1 VALUES(%d, '%.*s')", 
                                           i, 16, packet->test_data);
                if (sql) {
                    sqlite3_exec(db, sql, NULL, NULL, NULL);
                    sqlite3_free(sql);
                }
            }
            
            /* Try checkpoint while modifying data */
            for (int i = 0; i < 20; i++) {
                sqlite3_exec(db, "BEGIN", NULL, NULL, NULL);
                sqlite3_exec(db, "INSERT INTO t1 VALUES(100, 'race_test')", NULL, NULL, NULL);
                
                /* Attempt checkpoint during transaction */
                sqlite3_wal_checkpoint(db, NULL);
                
                sqlite3_exec(db, "COMMIT", NULL, NULL, NULL);
                
                /* Small delay to create race window */
                usleep(packet->delay_microsec % 1000);
            }
            break;
        }
        case 1: {
            /* Scenario 2: Multiple concurrent checkpoints */
            for (int i = 0; i < 15; i++) {
                char *sql = sqlite3_mprintf("INSERT INTO t1 VALUES(%d, 'checkpoint_test_%.*s')", 
                                           i, 8, packet->test_data);
                if (sql) {
                    sqlite3_exec(db, sql, NULL, NULL, NULL);
                    sqlite3_free(sql);
                }
                
                /* Try different checkpoint modes */
                int mode = (packet->checkpoint_mode + i) % 4;
                sqlite3_wal_checkpoint_v2(db, NULL, mode, NULL, NULL);
            }
            break;
        }
        case 2: {
            /* Scenario 3: Reader-writer conflict during checkpoint */
            sqlite3_exec(db, "BEGIN", NULL, NULL, NULL);
            
            for (int i = 0; i < 10; i++) {
                char *sql = sqlite3_mprintf("INSERT INTO t1 VALUES(%d, '%.*s')", 
                                           i + 1000, 12, packet->test_data);
                if (sql) {
                    sqlite3_exec(db, sql, NULL, NULL, NULL);
                    sqlite3_free(sql);
                }
                
                /* Try checkpoint during long transaction */
                if (i % 3 == 0) {
                    sqlite3_wal_checkpoint(db, NULL);
                }
            }
            
            sqlite3_exec(db, "COMMIT", NULL, NULL, NULL);
            break;
        }
        default: {
            /* Scenario 4: Complex WAL operations */
            for (int i = 0; i < 25; i++) {
                /* Mixed operations */
                switch (packet->sql_operations[i % 8] % 4) {
                    case 0:
                        sqlite3_exec(db, "INSERT INTO t1 VALUES(?, 'mixed_op')", NULL, NULL, NULL);
                        break;
                    case 1:
                        sqlite3_exec(db, "UPDATE t1 SET data = 'updated' WHERE id % 5 = 0", NULL, NULL, NULL);
                        break;
                    case 2:
                        sqlite3_exec(db, "DELETE FROM t1 WHERE id % 7 = 0", NULL, NULL, NULL);
                        break;
                    case 3:
                        sqlite3_wal_checkpoint_v2(db, NULL, SQLITE_CHECKPOINT_FULL, NULL, NULL);
                        break;
                }
                
                usleep(packet->delay_microsec % 500);
            }
            break;
        }
    }
    
    sqlite3_close(db);
    unlink(temp_db_path);
    return 0;
}

/*
** Memory Pressure Vulnerability Detection
** Tests memory allocation failure handling
*/
int fuzz_memory_pressure(FuzzCtx *ctx, const uint8_t *data, size_t size) {
    if (size < sizeof(memory_pressure_packet)) return 0;
    
    const memory_pressure_packet *packet = (const memory_pressure_packet *)data;
    
    /* Validation */
    if (packet->alloc_count > 1000) return 0;
    if (packet->alloc_size > 1000000) return 0;
    
    sqlite3 *db = NULL;
    int rc = sqlite3_open(":memory:", &db);
    if (rc != SQLITE_OK) return 0;
    
    /* Simulate memory pressure based on scenario */
    switch (packet->scenario & 0x7) {
        case 0: {
            /* Scenario 1: Gradual memory exhaustion */
            sqlite3_exec(db, "CREATE TABLE t1(data BLOB)", NULL, NULL, NULL);
            
            for (int i = 0; i < (int)packet->alloc_count && i < 100; i++) {
                size_t blob_size = (packet->alloc_size % 10000) + (i * 100);
                
                sqlite3_stmt *stmt;
                if (sqlite3_prepare_v2(db, "INSERT INTO t1 VALUES(randomblob(?))", -1, &stmt, NULL) == SQLITE_OK) {
                    sqlite3_bind_int(stmt, 1, (int)blob_size);
                    sqlite3_step(stmt);
                    sqlite3_finalize(stmt);
                }
                
                /* Occasionally trigger VACUUM to stress memory */
                if (i % 10 == 0) {
                    sqlite3_exec(db, "VACUUM", NULL, NULL, NULL);
                }
            }
            break;
        }
        case 1: {
            /* Scenario 2: Large single allocation */
            sqlite3_exec(db, "CREATE TABLE t1(huge_data TEXT)", NULL, NULL, NULL);
            
            size_t huge_size = packet->alloc_size % 1000000;
            char *huge_string = sqlite3_mprintf("%*s", (int)huge_size, "X");
            if (huge_string) {
                char *sql = sqlite3_mprintf("INSERT INTO t1 VALUES('%s')", huge_string);
                if (sql) {
                    sqlite3_exec(db, sql, NULL, NULL, NULL);
                    sqlite3_free(sql);
                }
                sqlite3_free(huge_string);
            }
            break;
        }
        case 2: {
            /* Scenario 3: Memory fragmentation */
            sqlite3_exec(db, "CREATE TABLE t1(frag_data)", NULL, NULL, NULL);
            
            /* Create fragmentation pattern */
            for (int i = 0; i < 50; i++) {
                size_t frag_size = (packet->alloc_size % 1000) + (i % 10) * 100;
                char *sql = sqlite3_mprintf("INSERT INTO t1 VALUES(randomblob(%d))", (int)frag_size);
                if (sql) {
                    sqlite3_exec(db, sql, NULL, NULL, NULL);
                    sqlite3_free(sql);
                }
                
                /* Create holes in memory by deleting every 3rd row */
                if (i % 3 == 0) {
                    sqlite3_exec(db, "DELETE FROM t1 WHERE rowid % 3 = 0", NULL, NULL, NULL);
                }
            }
            break;
        }
        default: {
            /* Scenario 4: Mixed memory stress */
            sqlite3_exec(db, "CREATE TABLE t1(mixed)", NULL, NULL, NULL);
            
            for (int i = 0; i < 30; i++) {
                /* Alternate between different operation types */
                switch (packet->test_operations[i % 16] % 4) {
                    case 0: {
                        char *sql = sqlite3_mprintf("INSERT INTO t1 VALUES(randomblob(%d))", 
                                                   (int)(packet->alloc_size % 5000));
                        if (sql) {
                            sqlite3_exec(db, sql, NULL, NULL, NULL);
                            sqlite3_free(sql);
                        }
                        break;
                    }
                    case 1:
                        sqlite3_exec(db, "SELECT length(mixed), hex(mixed) FROM t1", NULL, NULL, NULL);
                        break;
                    case 2:
                        sqlite3_exec(db, "UPDATE t1 SET mixed = mixed || mixed WHERE rowid % 2 = 0", NULL, NULL, NULL);
                        break;
                    case 3:
                        sqlite3_exec(db, "DELETE FROM t1 WHERE length(mixed) > 1000", NULL, NULL, NULL);
                        break;
                }
            }
            break;
        }
    }
    
    sqlite3_close(db);
    return 0;
}

/*
** Helper function to simulate memory pressure
*/
int simulate_memory_pressure(int alloc_count, size_t alloc_size) {
    void **ptrs = malloc(alloc_count * sizeof(void*));
    if (!ptrs) return -1;
    
    /* Allocate memory to create pressure */
    for (int i = 0; i < alloc_count; i++) {
        ptrs[i] = malloc(alloc_size);
        if (!ptrs[i]) {
            /* Free what we allocated so far */
            for (int j = 0; j < i; j++) {
                free(ptrs[j]);
            }
            free(ptrs);
            return i; /* Return how many we allocated */
        }
    }
    
    /* Keep memory allocated for a short time */
    usleep(1000);
    
    /* Free all allocated memory */
    for (int i = 0; i < alloc_count; i++) {
        free(ptrs[i]);
    }
    free(ptrs);
    
    return alloc_count;
}